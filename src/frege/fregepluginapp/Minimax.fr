-- inspired by http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf

module fregepluginapp.Minimax where

import Data.Tree                    -- make use of the Rose Tree in the stdlib

playerX =  1                        -- would be nicer to make those enums of a proper datatype (?)
playerO = -1
blank   =  0

opponent player = player * (-1)

data Board = Board {
    whosTurn :: Int,             -- who's turn it is to put the next mark on the board
    fields   :: [Int]            -- each board is a 0..8 list of placements: playerX, playerO, or blank
}

-- all possible boards that can arise from applying a valid move onto the current board
moves :: Board -> [Board]
moves board
    | hasWon board playerX = [] -- we have won  - no more valid moves
    | hasWon board playerO = [] -- we have lost - no more valid moves
    | otherwise = map (Board otherPlayer) boardFieldsAfterMove where
        otherPlayer                  = opponent board.whosTurn
        fieldsWithIndex              = zip board.fields [1..]
        blankIndexes                 = [ i | (content,i) <- fieldsWithIndex, content == blank]
        fieldsWithPlayerPlacedAt pos = [ if i==pos then board.whosTurn else content | (content,i) <- fieldsWithIndex]
        boardFieldsAfterMove         = map fieldsWithPlayerPlacedAt blankIndexes

-- a potentially endless repetition of a tree, where children are constructed by applying function f to the payload a.
repeatTree :: (a -> [a]) -> a -> Tree a
repeatTree f a = Node a (map (repeatTree f) (f a) )

-- the potentially endless game tree for a given board
gameTree :: Board -> Tree Board
gameTree board = repeatTree moves board

-- a static valuation of the board between -1 (playerX has lost) and 1 (playerX has won)
static :: Board -> Double
static board
    | hasWon board playerX =  1.0 -- well that could  be much more elaborate but we only consider wins ATM
    | hasWon board playerO = -1.0
    | otherwise            =  0.0

hasWon :: Board -> Int -> Bool
hasWon board player =
    or [hasTriple row player | row <- [ [0,1,2], [3,4,5], [6,7,8] ] ]   ||
    or [hasTriple col player | col <- [ [0,3,6], [1,4,7], [2,5,8] ] ]   ||
    hasTriple [6,4,2] player                                            ||
    hasTriple [0,4,8] player where
        hasTriple indexes player = and [board.fields !! x == player | x <- indexes ]

-- The heart of the game:
-- the alpha-beta minimax algorithm on any tree of comparable payload.

maximize :: Ord a => Tree a -> a
maximize (Node a []) = a
maximize (Node a children) = maximum (map minimize children) -- what is the value of our best move

minimize :: Ord a => Tree a -> a
minimize (Node a []) = a
minimize (Node a children) = minimum (map maximize children) -- assuming the opponent does his best one

-- Creating the game tree from valid moves can lead to endless or at least very large trees.
-- Pruning the tree is a totally separate operation that will later limit the generation.

prune 0 (Node a children) = Node a []
prune n (Node a children) = Node a (map (prune (n-1)) children)

-- Evaluating a board that results from applying a move is a composition of creating a tree of valid
-- moves, limiting it, mapping the leaves to their static valuation and minimaxing the whole.
-- (As opposed to the paper, we use minimize, not maximize, to start the evaluation since we calculate the first
-- level of the tree ourselves in order to have the maximum move handily available.
-- Thus, the sequence of min/max starts one level below.)
-- A function f is applied when mapping a tree of Boards to something that can be compared.

evaluateBy :: Ord a => (Board -> a) -> Int -> Board -> a
evaluateBy f lookahead = minimize . fmap f . prune lookahead . gameTree

nowValue :: Int -> Board -> (Double, Board)
nowValue lookahead board = (evaluateBy static lookahead board, board)

-- A second use of the same approach that looks into the expected future and captures is for later display

endValue :: Int -> Board -> (Double, Board)
endValue = evaluateBy capture where
    capture board = (static board, board)

derive   Eq  Board                          -- little trick to make the valuation tuple comparable
instance Ord Board where
    (<=>) a b = EQ

-- -------------------     for integrating with the environment     --------------------------------

nextBoard :: Int -> JArray Int -> JArray Int
nextBoard = nextBoardBy nowValue

forecast :: Int -> JArray Int -> JArray Int
forecast = nextBoardBy endValue

nextBoardBy probe lookahead inFields = unBoard bestMove where
     possibleMoves  = moves (Board playerX inFields.toList)
     evaluatedMoves = map (probe lookahead) possibleMoves
     bestMove       = bestOf evaluatedMoves where
         bestOf []  = Board playerX [] -- indication that there was no possible move
         bestOf ms  = snd $ maximum ms

unBoard :: Board -> JArray Int
unBoard board = arrayFromList board.fields

